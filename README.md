# Высшая школа программирования Сергея Бобровского
##  Второй курс по алгоритмам/структурам данных.
### Деревья

В классе **SimpleTree** нам потребуются:
- добавить текущему узлу (первый параметр метода добавления узла) новый узел (второй параметр метода добавления узла) в качестве дочернего (тест: проверяем наличие добавленного узла);
- удалить некорневой узел (удаляется узел вместе со всем поддеревом) (тест: проверяем отсутствие удалённого узла и его потомков);
- последовательно обойти всё дерево и сформировать список всех узлов в произвольном порядке;
- найти список подходящих узлов по заданному значению (тест: проверяем результат с тестовым списком);
- переместить некорневой узел дочерним узлом в другое место дерева (вместе с его поддеревом), для чего воспользуйтесь предыдущими методами (тест: проверяем, что узел отсутствует там где был исходно и появился в новом месте);
- подсчитать общее количество узлов в дереве, и количество листьев (тест: проверяем на контрольном дереве количество узлов и листьев).

Также напишите метод, который перебирает всё дерево и прописывает каждому узлу его уровень.
Придумайте, как лучше организовать поддержку уровня узлов без анализа всего дерева.

### Двоичные деревья поиска.
В задании необходимо реализовать:
- метод поиска (тест: проверяем поиск отсутствующего ключа в двух вариантах (запрошенный ключ добавляем либо левому, либо правому потомку) и поиск присутствующего ключа);
- метод добавления нового узла, задаём добавляемый ключ и соответствующее ему значение (тесты: проверяем исходное отсутствие узла по такому ключу в дереве и его наличие после добавления, в двух вариантах -- левым или правым узлом родителя, а также попытку добавления ключа, которое уже имеется в дереве, в таком случае ничего с деревом не делаем);
- поиск максимального и минимального ключей, начиная с заданного узла (тест, 4 варианта: поиск начиная с корня и поиск начиная с поддерева, ищем максимальный и минимальный ключ);
- метод удаления узла по его ключу (тест: проверяем исходное наличие узла у родителя, его отсутствие после удаления, и результат работы метода).

### Способы обхода дерева.
Задание:
- Реализуйте дополнительный метод обхода дерева WideAllNodes() без параметров для класса из занятия по двоичным деревьям, так, чтобы он реализовывал алгоритм поиска в ширину, начиная с корня.
 - Реализуйте дополнительный метод обхода дерева DeepAllNodes(), начиная с корня, которому задаётся один целый параметр, принимающий значения 0 (in-order), 1 (post-order) и 2 (pre-order). В зависимости от этого параметра метод DeepAllNodes() реализует соответствующую форму алгоритма поиска в глубину.

Эти алгоритмы формируют на выходе стандартный список из объектов BSTNode (List в C#, tuple в Python, ArrayList в Java).
